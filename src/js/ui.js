// =========================================================================
// UI.JS: RESPONS√ÅVEL PELA L√ìGICA DE INTERA√á√ÉO (Votos, Submiss√µes, Exclus√µes)
// =========================================================================

// Importa√ß√µes cruciais para transa√ß√µes e estado:
import * as auth from './auth.js';
import * as blockchain from './blockchain.js';
// Importa o Poller para for√ßar a atualiza√ß√£o ap√≥s uma transa√ß√£o:
import { currentRenderVotes, pollForEdit,startPostViewPoller } from './poller.js'; 
// Importa utilit√°rios necess√°rios para submiss√£o/erro:
import { getDecryptedPostingKey } from './utils.js'; 
import { 
    postViewState, 
    renderCurrentReplyPage, 
    renderReplyPagination,
    REPLIES_PER_PAGE
} from './render.js';

import { getEasyMDEInstance, setEasyMDEInstance, appContainer, handleRouteChange } from './app.js';

// Importa a inst√¢ncia do EasyMDE, que ainda est√° em app.js (AJUSTE TEMPOR√ÅRIO NECESS√ÅRIO)
// Se o easyMDEInstance for definido no app.js, ele deve ser exportado de l√° (OU movido)

// NOTA IMPORTANTE: Se easyMDEInstance estiver em app.js, 
// ele deve ser exportado de app.js para ser importado aqui.
// Para fins deste guia, assumiremos que ele foi movido para o topo do ui.js,
// ou que √© passado como argumento.

// üö® NOVO: Fun√ß√£o auxiliar para obter o objeto Keychain dispon√≠vel
function getAvailableKeychain() {
    // Prioriza Hive para seus testes, mas retorna Blurt se existir
    if (window.hive_keychain) {
        return window.blurt_keychain;
    }
    if (window.blurt_keychain) {
        return window.blurt_keychain;
    }
    return window.blurt_keychain;
}

// -------------------------------------------------------------------
// 1. L√ìGICA DE VOTO
// -------------------------------------------------------------------

/**
 * Lida com o clique no bot√£o de voto.
 */
export async function handleVoteClick(e) {
    e.preventDefault();
    const voteBtn = e.target.closest('.vote-btn');
    if (!voteBtn) return;
    
    const user = auth.getCurrentUser();
    if (!user) {
        Toastify({ text: "Please log in to vote.", duration: 3000 }).showToast(); 
        return;
    }

    const author = voteBtn.getAttribute('data-author');
    const permlink = voteBtn.getAttribute('data-permlink');
    const isUpvoted = voteBtn.classList.contains('btn-success');
    
    // Determina o peso do voto
    // O Keychain usa o peso em percentual (0 a 10000)
    const weight = isUpvoted ? 0 : 10000; 

    console.log('auth.isKeychainUseraaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa');
    console.log(auth.isKeychainUser);

    try {
        if (auth.isKeychainUser()) {
            // ==========================================================
            // ‚≠êÔ∏è L√ìGICA KEYCHAIN
            // ==========================================================
            const keychain = getAvailableKeychain();
            if (!keychain) {
                throw new Error("Keychain n√£o est√° instalado.");
            }
            
            await new Promise((resolve, reject) => {
                // Usa requestVote com a chave 'Posting' (Padr√£o para votos)
                keychain.requestVote(
                    user, 
                    permlink, 
                    author, // Note a ordem: permlink e author s√£o troc√°veis no Blurt Keychain
                    weight, 
                    (response) => {
                        if (response.success) {
                            resolve(response);
                        } else {
                            // Erro pode ser cancelamento do usu√°rio, etc.
                            reject(new Error(response.message || 'Voto Keychain falhou.'));
                        }
                    }
                );
            });
            
        } else {
            // ==========================================================
            // üîë L√ìGICA CHAVE PRIVADA TRADICIONAL
            // ==========================================================
            const postingKey = await getDecryptedPostingKey();
            if (!postingKey) return; // Transa√ß√£o cancelada pelo usu√°rio (ou sess√£o bloqueada)
            
            await blockchain.broadcastVote(user, postingKey, author, permlink, weight);
        }

        // --- L√≥gica de Sucesso (Comum a ambos os m√©todos) ---

        console.log('Sucesssoooooooooooooooooooooooooooooooooooooooo');
        
        // üö® CHAMA O POLLER PARA ATUALIZAR OS VOTOS
        setTimeout(() => {
            if (typeof currentRenderVotes === 'function') {
                console.log('Chamando currentRenderVotes ap√≥s voto');
                currentRenderVotes(true);

            }else {
             // Caso o poller n√£o esteja ativo, faz uma atualiza√ß√£o r√°pida da UI
             voteBtn.classList.toggle('btn-success');
             voteBtn.classList.toggle('btn-outline-success');
             console.log('Falhoooooooooooooooooooooooooooooooooooooooo');
            }
        }, 5000); // 5 segundos

        Toastify({ text: isUpvoted ? "Unvoted successfully!" : "Voted successfully!", duration: 3000, newWindow: true, gravity: "bottom", position: "left", className: isUpvoted ? "bg-warning" : "bg-success"}).showToast();
        
    } catch (error) {
        // L√≥gica de Erro
        Toastify({ text: `Vote failed: ${error.message}`, duration: 5000, className: "bg-danger"}).showToast();
        console.error("Vote error:", error);
    }
}

// -------------------------------------------------------------------
// 2. L√ìGICA DE SUBMISS√ÉO DE NOVO T√ìPICO
// -------------------------------------------------------------------

/**
 * Lida com a submiss√£o de um novo t√≥pico.
 */
export async function handlePostSubmit(e, draftKey, easyMDEInstance) {
    e.preventDefault();
    const title = document.getElementById('topic-title').value;
    const body = easyMDEInstance.value();
    const errorDiv = document.getElementById('post-error');
    const categoryId = new URLSearchParams(window.location.search).get('new_topic_in');
    
    // ... (Valida√ß√£o de campos) ...

    e.target.querySelector('button[type="submit"]').disabled = true;
    errorDiv.classList.add('d-none');
    
    // Vari√°veis que ser√£o preenchidas no try/catch
    let result;
    const author = auth.getCurrentUser();
    
    try {
        if (auth.isKeychainUser()) {
            // ==========================================================
            // ‚≠êÔ∏è L√ìGICA KEYCHAIN
            // ==========================================================
            const keychain = getAvailableKeychain();
            if (!keychain) {
                throw new Error("Keychain n√£o est√° instalado.");
            }

            // Prepara o array de opera√ß√µes para o Keychain
            const operations = blockchain.preparePostOperations(author, categoryId, title, body);
            const finalPermlink = operations[0][1].permlink; // Obt√©m o permlink gerado
            
            await new Promise((resolve, reject) => {
                // Usa requestBroadcast para enviar m√∫ltiplas opera√ß√µes
                keychain.requestBroadcast(
                    author, // O nome de usu√°rio para assinatura
                    operations, // O array de opera√ß√µes
                    'Posting', // Chave de postagem
                    (response) => {
                        if (response.success) {
                            // Define o resultado para o tratamento p√≥s-transa√ß√£o
                            result = { finalPermlink: finalPermlink };
                            resolve(response);
                        } else {
                            reject(new Error(response.message || 'Submiss√£o Keychain falhou.'));
                        }
                    }
                );
            });
            
        } else {
            // ==========================================================
            // üîë L√ìGICA CHAVE PRIVADA TRADICIONAL
            // ==========================================================
            const key = await getDecryptedPostingKey(); 
            if (!key) {
                e.target.querySelector('button[type="submit"]').disabled = false;
                return;
            }

            // Chama a fun√ß√£o existente que usa blurt.broadcast.send
            result = await blockchain.broadcastPost(author, key, categoryId, title, body);
        }

        // --- L√≥gica de Sucesso (Comum a ambos os m√©todos) ---

        if (draftKey) {
            localStorage.removeItem(draftKey);
            localStorage.removeItem(`${draftKey}-title`);
        }

        appContainer.innerHTML = `<div class="text-center mt-5"><h4>Post submitted successfully!</h4><p>Waiting for it to be confirmed on the blockchain...</p><div class="spinner-border" role="status"><span class="visually-hidden">Loading...</span></div></div>`;
        
        // üö® O result.finalPermlink deve vir do broadcastPost ou ser definido acima
        pollForPost(author, result.finalPermlink); 
        
    } catch (error) {
        // L√≥gica de Erro
        errorDiv.textContent = `Error: ${error.message}`;
        errorDiv.classList.remove('d-none');
        e.target.querySelector('button[type="submit"]').disabled = false;
    }
}

// -------------------------------------------------------------------
// 3. L√ìGICA DE SUBMISS√ÉO DE RESPOSTA
// -------------------------------------------------------------------

/**
 * Lida com a submiss√£o de uma resposta/r√©plica.
 */

export async function handleReplySubmit(e, parentAuthor, parentPermlink) {
    e.preventDefault();
    
    const currentMDE = getEasyMDEInstance();
    const body = currentMDE ? currentMDE.value() : ''; 
    const errorDiv = document.getElementById('reply-error');

    if (!body.trim()) {
        errorDiv.textContent = "Reply content cannot be empty.";
        errorDiv.classList.remove('d-none');
        return;
    }

    e.target.querySelector('button[type="submit"]').disabled = true;
    errorDiv.classList.add('d-none');

    const author = auth.getCurrentUser();
    //let originalReplyCount;

    try {
        // 1. Conta as respostas originais (Para o poller)
        //const { replies } = await blockchain.getPostAndDirectReplies(parentAuthor, parentPermlink);
        //originalReplyCount = replies.length;
        
        if (auth.isKeychainUser()) {
            // ==========================================================
            // ‚≠êÔ∏è L√ìGICA KEYCHAIN
            // ==========================================================
            const keychain = getAvailableKeychain();
            if (!keychain) {
                throw new Error("Keychain n√£o est√° instalado.");
            }

            // Prepara as opera√ß√µes para o Keychain
            const operations = blockchain.prepareReplyOperations(author, parentAuthor, parentPermlink, body);
            
            await new Promise((resolve, reject) => {
                // Usa requestBroadcast para enviar o array de opera√ß√µes
                keychain.requestBroadcast(
                    author, // Usu√°rio logado
                    operations, // Array de opera√ß√µes
                    'Posting', // Chave
                    (response) => {
                        if (response.success) {
                            resolve(response);
                        } else {
                            reject(new Error(response.message || 'Resposta Keychain falhou.'));
                        }
                    }
                );
            });
            
        } else {
            // ==========================================================
            // üîë L√ìGICA CHAVE PRIVADA TRADICIONAL
            // ==========================================================
            const key = await getDecryptedPostingKey();
            if (!key) {
                 e.target.querySelector('button[type="submit"]').disabled = false;
                return;
            }
            
            await blockchain.broadcastReply(author, key, parentAuthor, parentPermlink, body);
        }

        // --- L√≥gica de Sucesso (Comum a ambos os m√©todos) ---

        // 2. Limpeza do Editor e da Refer√™ncia Global
        if (currentMDE) {
            currentMDE.toTextArea();
            setEasyMDEInstance(null);
        }

        e.target.closest('#reply-form').innerHTML = '<p class="text-success">Reply submitted! Waiting for blockchain confirmation...</p>';

        // 3. Poller (N√£o precisa de modifica√ß√£o aqui, pois √© baseado em contagem)
        let attempts = 0;
        const maxAttempts = 2;
        let originalReplyCount = postViewState.allReplies.length;

        const poller = setInterval(async () => {
        attempts++;
        
        // A. For√ßa o fetch de todos os replies e atualiza o postViewState global
        // Usamos o poller de votos que j√° faz o getPostWithReplies e atualiza o estado
        if (typeof currentRenderVotes === 'function') {
            // currentRenderVotes(true) faz o fetch e atualiza postViewState.allReplies
            await currentRenderVotes(true); 
        } else {
            // Se currentRenderVotes n√£o estiver dispon√≠vel, fazemos um fetch simples
            await blockchain.getPostWithReplies(parentAuthor, parentPermlink);
        }
        
        // Assumimos que a atualiza√ß√£o do postViewState foi bem-sucedida pelo currentRenderVotes(true)
        const { allReplies } = postViewState;

        if (allReplies && allReplies.length > originalReplyCount) {
            clearInterval(poller);
        
        // 1. Calcula qual √© a √∫ltima p√°gina (onde o novo reply estar√°)
        // postViewState.allReplies agora cont√©m o reply rec√©m-postado
        const totalReplies = allReplies.length; 
        const lastPage = Math.ceil(totalReplies / REPLIES_PER_PAGE);

        // 2. Atualiza o estado da p√°gina atual
        postViewState.currentReplyPage = lastPage;
        
        // 3. Atualiza a URL para refletir a nova p√°gina (opcional, mas bom para hist√≥rico)
        const newUrl = `?post=@${postViewState.author}/${postViewState.permlink}&reply_page=${lastPage}`;
        history.pushState({}, '', newUrl);

        // 4. Re-renderiza a p√°gina e os bot√µes de pagina√ß√£o
        // üö® Estas fun√ß√µes devem ser importadas do seu render.js
        if (typeof renderCurrentReplyPage === 'function' && typeof renderReplyPagination === 'function') {
            renderCurrentReplyPage(); // Renderiza a lista de replies na nova p√°gina
            renderReplyPagination();  // Atualiza os bot√µes de pagina√ß√£o
            await currentRenderVotes(true); 
        }
        
        // 5. Opcional: Rola suavemente para a se√ß√£o de replies
        document.getElementById('post-replies-container').scrollIntoView({ behavior: 'smooth' });
        
    } else if (attempts >= maxAttempts) {
        clearInterval(poller);
        Toastify({ text: "Reply submitted, but a temporary error prevents display. Please refresh.", duration: 8000, backgroundColor: "red" }).showToast();
    }
}, 7000); // Checa a cada 7 segundos

    } catch (error) {
        errorDiv.textContent = `Error: ${error.message}`;
        errorDiv.classList.remove('d-none');
        e.target.querySelector('button[type="submit"]').disabled = false;
    }
    

}

// -------------------------------------------------------------------
// 4. L√ìGICA DE EDI√á√ÉO E EXCLUS√ÉO
// -------------------------------------------------------------------

export async function handleEditSubmit(e, originalPost, draftKey) {
    e.preventDefault();
    
    const currentMDE = getEasyMDEInstance();
    const titleInput = document.getElementById('edit-title');
    const errorDiv = document.getElementById('edit-error');

    let title = originalPost.title;
    let body = originalPost.body;

    // ... (L√≥gica para obter o title e body do editor, sem altera√ß√£o necess√°ria)
    if (currentMDE) { body = currentMDE.value(); } else { /* fallback */ }
    if (titleInput) { title = titleInput.value; }
    // ... (Valida√ß√£o) ...

    e.target.querySelector('button[type="submit"]').disabled = true;

    try {
        const originalLastUpdate = originalPost.last_update;

        if (auth.isKeychainUser()) {
            // ==========================================================
            // ‚≠êÔ∏è L√ìGICA KEYCHAIN
            // ==========================================================
            const keychain = getAvailableKeychain();
            if (!keychain) {
                throw new Error("Keychain n√£o est√° instalado.");
            }

            // Prepara as opera√ß√µes para a edi√ß√£o
            const operations = blockchain.prepareEditOperations(originalPost, title, body);
            
            await new Promise((resolve, reject) => {
                // Usa requestBroadcast para enviar o array de opera√ß√µes
                keychain.requestBroadcast(
                    originalPost.author, // Usu√°rio logado
                    operations, // Array de opera√ß√µes
                    'Posting', // Chave
                    (response) => {
                        if (response.success) {
                            resolve(response);
                        } else {
                            reject(new Error(response.message || 'Edi√ß√£o Keychain falhou.'));
                        }
                    }
                );
            });
            
        } else {
            // ==========================================================
            // üîë L√ìGICA CHAVE PRIVADA TRADICIONAL
            // ==========================================================
            const key = await getDecryptedPostingKey();
            if (!key) {
                e.target.querySelector('button[type="submit"]').disabled = false;
                return;
            }
            
            // Chama a fun√ß√£o existente que usa blurt.broadcast.send
            await blockchain.broadcastEdit(originalPost.author, key, originalPost, title, body);
        }

        // --- L√≥gica de Sucesso (Comum a ambos os m√©todos) ---

        if (currentMDE) {
             try { currentMDE.toTextArea(); } catch(err) { console.error("Error cleaning MDE:", err); }
             setEasyMDEInstance(null); // Limpa a refer√™ncia global
        }
        
        // Limpeza de rascunhos
        if (draftKey) {
            localStorage.removeItem(draftKey);
            localStorage.removeItem(`${draftKey}-title`);
        }

        appContainer.innerHTML = `<div class="text-center mt-5"><h4>Changes submitted!</h4><p>Waiting for confirmation...</p><div class="spinner-border"></div></div>`;
        pollForEdit(originalPost.author, originalPost.permlink, originalLastUpdate);

    } catch (error) {
        errorDiv.textContent = `Error: ${error.message}`;
        errorDiv.classList.remove('d-none');
        e.target.querySelector('button[type="submit"]').disabled = false;
    }
}
// Local: js/modules/ui.js (dentro de handleDeleteClick)

// Local: js/modules/ui.js

// Local: js/modules/ui.js

// üö® Lembre-se de que o Bootstrap deve estar carregado globalmente ou importado (se voc√™ estiver usando m√≥dulos JS para o Bootstrap).

export async function handleDeleteClick(e, author, permlink) {
    e.preventDefault();

    // üö® REMOVIDO: A obten√ß√£o de 'key' na linha 4 (const key = await getDecryptedPostingKey();)
    // Foi removida para n√£o bloquear o fluxo do Keychain.

    // 1. Cria e mostra a inst√¢ncia do Modal (Fluxo inalterado)
    const deleteModalEl = document.getElementById('deleteConfirmModal');
    if (!deleteModalEl) {
        console.error("Delete confirmation modal not found in DOM.");
        Toastify({ text: "Erro: Modal de exclus√£o n√£o encontrado.", backgroundColor: "red" }).showToast();
        return;
    }
    
    const deleteModal = new bootstrap.Modal(deleteModalEl);
    deleteModal.show();
    
    // 2. Anexa o listener de exclus√£o ao bot√£o de confirma√ß√£o do modal
    const confirmBtn = document.getElementById('confirmDeleteBtn');
    
    // Clonar e substituir o bot√£o para limpar listeners antigos
    const newConfirmBtn = confirmBtn.cloneNode(true);
    confirmBtn.parentNode.replaceChild(newConfirmBtn, confirmBtn);

    newConfirmBtn.addEventListener('click', async function deleteListener(clickEvent) {
        newConfirmBtn.removeEventListener('click', deleteListener); 
        newConfirmBtn.disabled = true;

        try {
            deleteModal.hide();
            
            // üö® 3. L√ìGICA CONDICIONAL DE TRANSA√á√ÉO
            if (auth.isKeychainUser()) {
                // ==========================================================
                // ‚≠êÔ∏è L√ìGICA KEYCHAIN
                // ==========================================================
                const keychain = getAvailableKeychain();
                if (!keychain) {
                    throw new Error("Keychain n√£o est√° instalado.");
                }

                const operations = blockchain.prepareDeleteOperations(author, permlink);
                
                await new Promise((resolve, reject) => {
                    keychain.requestBroadcast(
                        author, // Usu√°rio logado
                        operations, 
                        'Posting', 
                        (response) => {
                            if (response.success) {
                                resolve(response);
                            } else {
                                reject(new Error(response.message || 'Exclus√£o Keychain falhou.'));
                            }
                        }
                    );
                });
                
            } else {
                // ==========================================================
                // üîë L√ìGICA CHAVE PRIVADA TRADICIONAL
                // ==========================================================
                // Agora, a chave √© obtida aqui, DENTRO do listener
                const key = await getDecryptedPostingKey();
                if (!key) {
                    throw new Error("Transa√ß√£o cancelada. Chave de postagem n√£o fornecida.");
                }
                
                // Executa a Transa√ß√£o de Exclus√£o
                await blockchain.broadcastDelete(author, key, permlink); 
            }
            
            // 4. Atualiza o DOM e notifica (Comum a ambos)
            const elementToDelete = e.target.closest('.list-group-item, .card, .post-container'); 
            
            if (elementToDelete) {
                elementToDelete.innerHTML = '<p class="text-muted">[Este conte√∫do foi exclu√≠do]</p>';
            } else {
                handleRouteChange(); 
            }
            
            Toastify({ text: "Conte√∫do exclu√≠do com sucesso.", backgroundColor: "green" }).showToast();

        } catch (error) {
            deleteModal.hide();
            console.error("Delete failed:", error);
            Toastify({ text: `Falha ao excluir: ${error.message}`, backgroundColor: "red" }).showToast();
            newConfirmBtn.disabled = false; // Reabilitar em caso de falha
        }
    });
}